[toc]

# Algorithm Problem Solving

## 알고리즘

- 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법을 말하며, 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법이다.

---

### 알고리즘을 표현하는 방법

1. 의사코드(슈도코드,Pseudocode)
2. 순서도

---

### 좋은 알고리즘이란?

1. 얼마만큼의 **정확성**을 가지고 동작하는가?
2. 얼마나 작은 **작업량**으로 원하는 결과를 얻어내는가?
3. 얼마나 **적은 메모리**를 사용하는가?
4. 얼마나 **단순**한가?
5. 더 이상 개선할 여지없이 **최적화**되었는가?

---

### 시간 복잡도 (Time Complexity)

- 실제 걸리는 시간을 측정
- 실행되는 명령문의 개수를 계산

#### 빅-오(O) 표기법

- 시간 복잡도 함수 중에서 가장 큰 영향력을 주는 n에 대한 항만을 표시
- 계수(Coefficient)는 생략하여 표시

```text
O(2n+1) = O(2n) = O(n)
```





## 배열

## 정렬

- 2개 이상의 자료를 특정 기준에 의해 작은 값부터 큰 값 ( =>오름차순 ) 혹은 그 반대 ( => 내림차순 )의 순서대로 재배열 하는것
- 정렬에서 `키랄 자료를 정렬하는 기준이 되는 특정 값`을 말한다
  - 서류를 번호대로 정렬하기 => 키 : 서류번호
  - 카드를 번호대로 정렬하기 => 키 : 카드번호
- 대표적인 정렬 방식의 종류
  - 버블 정렬
  - 카운팅 정렬
  - 선택 정렬
  - 퀵 정렬
  - 삽입 정렬
  - 병합 정렬

### 버블 정렬 (Bubble Sort)

- 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식
- [정렬과정]
  - 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 마지막 자리까지 이동
  - 한 단계가 끝나면 가장 큰 원소 또는 가장 작은 원소가 마지막 자리로 정렬됨
  - 교환하며 자리를 이동하는 모습이 물 위에 올라오는 거품모양 같아서 버블 정렬이라고 함
- 시간 복잡도 : `O(n^2)`



### 카운팅 정렬 (Counting Sort)

### 완전검색 (Exhaustive Search)

- 완전 검색 방법은 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법이다.
- 모든 경우의 수를 테스트한 후, 최종 해법을 도출한다.
- 일반적으로 경우의 수가 상대적으로 작을 때 유용하다.
- 수행 속도는 느리지만, 해답을 찾아내지 못할 확률이 작다.

---

### Baby-gin Game

[ **설명** ]

- 0-9 사이의 숫자 카드에서 임의의 카드 6장을 뽑았을 때, 3장의 카드가 연속적인 번호를 갖는 경우를 run이라 하고, 3장의 카드가 동일한 번호를 갖는 경우를 triplete이라고 한다.
- 그리고, 6장의  카드가 run과 triplete로만 구성된 경우를 baby-gin으로 부른다.
- 6자리의 숫자를 입력 받아 baby-gin 여부를 판단하는 프로그램을 작성하라

[ **입력 예** ]

- 667767은 두 개의 triplete이므로 baby-gin이다. (666,777)
- 054060은 한 개의 run과 한 개의 triplete이므로 역시 baby-gin이다. (456,000)
- 101123은 한 개의 triplete가 존재하나 023이 run이 아니므로 baby-gin이 아니다.

---

#### 완전 검색을 활용한 Baby-gin 접근방법

- 고려할 수 있는 모든 경우의 수 생성하기

  - 6개의 숫자로 만들 수 있는 모든 숫자 나열하기 (중복 포함)

  - 예시 입력으로 [2,3,5,7,7,7]을 받은경우

    ```text
    2 3 5 7 7 7
    2 3 7 5 7 7
    ...
    7 7 7 5 3 2
    ```

- 해답 테스트하기

  - 앞의 3자리와 뒤의 3자리를 잘라 판단한다.

  - ```text
    2 3 5  7 7 7
    _____  _____
    해당X  triplete  => baby-gin 아님!
    ```

---

### 순열 활용방법

[ **순열(Permutation)** ]

- 서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는 것
- 서로 다른 n개 중 r개를 택하는 순열은 아래와 같이 표현한다.
  - `nPr`
    - nPr = n * (n-1) * (n-2) * ... * (n-r+1)
- nPn = n!이라고 표기하고 Factorial이라 부른다.
  - n! = n * (n-1) * (n-2) * ... * 2 * 1

- 예) {1,2,3}을 포함하는 모든 순열을 생성하는 함수

  - 동일한 숙자가 포함되지 않았을 때, 각 자리 수 별로 loop을 이용해 아래롸 같이 구현가능

  - ```python
    for i1 in range(1,4):
        for i2 in range(1,4):
            if i2 != i1 :
                for i3 in range(1,4):
                    if i3 != i1 and i3 != i2 :
                        print(i1,i2,i3)
    ```



## 그리디 (Greedy Alogorithm)

- 최적 해를 구하는데 사용되는 근시안적인 방법
  - 여러 경우 중 하나를 결정해야 할 때마다 **그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식**으로 진행하여 최종적인 해답에 도달함
  - 각 선택의 시점에서 이루어지는 결정은 지역적으로는 최적이지만, 그것들을 계속 수집하여 최종적인 해답을 만들었다고 하여, 그것이 **최적이라는 보장은 없음**
  - 일반적으로, 머리속에 떠오르는 생각을 검증 없이 바로 구현하면 **Greedy 접근**이 됨

### 탐욕 알고리즘의 수행 과정

1. 해 선택 : 현재 상태에서 부분 문제의 최적 해를 구한 뒤, 이를 **부분 해 집합에 추가함**
2. 실행 가능성 검사 : 새로운 부분 해 집합이 실행 가능한지를 확인 즉, **문제의 제약 조건을 위반하지 않는지를 검사함**
3. 해 검사 : 새로운 부분 해 집합이 **문제의 해가 되는지를 확인** , 아직 전체 문제의 해가 완성되지 않았다면 **해 선택부터 다시시작함**

---

### 거스름돈 줄이기

